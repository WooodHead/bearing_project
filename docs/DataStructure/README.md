# 数据结构 data structure

内存的基本单位是以一个字节大小，一个字节=8位


- 数组

对于指定下标的查找，时间复杂度为O(1)
通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)
当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)
对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)

- 线性链表

对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)
而查找操作需要遍历链表逐一进行比对，复杂度为O(n)

- 二叉树

对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)

- 哈希表

添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)
原因：
哈希表的主干就是数组，整体由数组+链表组成，链表则是主要为了解决哈希冲突而存在的
存储位置 = f(关键字)
f一般称为哈希函数
值通过哈希函数直接一次找到对应的位置

哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法
而HashMap即是采用了链地址法，也就是数组+链表的方式

数据结构的物理存储结构只有两种：
1、顺序存储结构
2、链式存储结构
像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式

HashMap的一个构造函数，两个参数initialCapacity,loadFactor 初始容量和负载因子

HashMap有三个构造函数，可以选用无参构造函数，不进行设置。默认值分别是16和0.75

官方的建议是initailCapacity设置成2的n次幂，laodFactor根据业务需求，如果迭代性能不是很重要，可以设置大一下。

扩容
HashMap每次put操作是都会检查一遍 size（当前容量）>initailCapacity*loadFactor 是否成立。如果不成立则HashMap扩容为以前的两倍（数组扩成两倍）

负载因子的大小决定了HashMap的数据密度
负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成查询或插入时的比较次数增多，性能会下降。
负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。


## 链表

### 如何判断链表有环？
快慢指针，定义2个指针，让指针1每次向下移动一个节点，让指针2每次向下移动两个节点
例如链表A->B->C->D->B->C->D
假设从链表头节点到入环点的距离是D，链表的环长是S。
那么循环会进行S次（为什么是S次，有心的同学可以自己揣摩下），可以简单理解为O（N）。
除了两个指针以外，没有使用任何额外存储空间，所以空间复杂度是O（1）。

### 如何找出有环链表的入环点？
分别用fast，slow指向链表头部
slow每次走一步，fast每次走二步
fast slow第一次相遇的时候，将fast重新指向头节点
再每个都走一步，再次相遇的点，就是入环点

### 如何判断两个单链表是否相交，以及相交点？


## 链表不同语言的实现

在C/C++中，通常采用“指针+结构体”来实现链表；
而在Python中，则可以采用“引用+类”来实现链表

很多的教材都是用C语言实现链表，因为C有指针，可以很方便的控制内存，很方便就实现链表；
其他的语言，则没那么方便，有很多都是用模拟链表，因为python是动态语言，可以直接把对象赋值给新的变量。


平衡树

红黑树

谈一个项目
